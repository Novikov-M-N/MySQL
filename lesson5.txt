# 1. Реализовать практические задания на примере других таблиц и запросов.
# Блокировка таблиц показана на скриншотах Lesson5Homework_table_blocked.png и Lesson5Homework_table_unblocked.png

# 2. Подумать, какие операции являются транзакционными, и написать несколько примеров с транзакционными запросами.

# В транзакции можно обернуть процедуру принятия сотрудника на работу:
# занесение его в таблицу сотрудников, в отдел, в начальники (если приходит сразу на место начальника отдела), присвоение должности.
# Данные операции имеет смысл заключать в транзакцию, т.к. в каком-нибудь отчёте может потребоваться, например, количество сотрудников в отделе
# с перечислением должностей, а эти данные находятся в разных таблицах, и при трудоустройстве нового сотрудника есть момент, когда его данные
# присутствуют в одной таблице и отсутствуют в другой, т.е. в отчёт могут попасть не целостные данные.
BEGIN;
	INSERT INTO
		employees
	VALUES
		(5001, '1980-01-01', 'Ivan', 'Ivanov', 'M', CURDATE());
        
	INSERT INTO
		dept_emp
	VALUES
		(5001, 'd005', CURDATE(), '9999-01-01');

	INSERT INTO
		titles
	VALUES
		(5001, 'Engineer', CURDATE(), '9999-01-01');
COMMIT;

# По тем же причинам имеет смысл заключить в транзакцию все процедуры при увольнении работника.
BEGIN;
	DELETE FROM
		employees
	WHERE
		emp_no = 5001;
        
	DELETE FROM
		dept_emp
	WHERE
		emp_no = 5001;

	DELETE FROM
		dept_manager
	WHERE
		emp_no = 5001;

	DELETE FROM
		titles
	WHERE
		emp_no = 5001;
COMMIT;

# 3. Проанализировать несколько запросов с помощью EXPLAIN.
# Создадим запрос, который в реальности никто делать не будет, но для загрузки БД подойдёт.
# Выбор всех инженеров из отдела разработки, которым должность инженера присвоена одновременно с зачислением в отдел.
# Временно отключим индекс по полю dept_no для таблицы dept_emp.
SELECT 
    *
FROM
    employees.titles
WHERE
 	title = 'Engineer'
     AND
    from_date IN (
		SELECT
			from_date
		FROM
			dept_emp
		WHERE
			dept_no = 'd005'
    )
;
# Анализ запроса представлен на скриншоте lesson5Homework_3_1.png.
# Стоимость запроса в единицах MySQL составила 182965821.
# Вернём индекс по полю emp_no и повторим анализ.
# Анализ запроса представлен на скриншоте lesson5Homework_3_2.png.
# Стоимость запроса в единицах MySQL составила     79046.
# Добавим индексы на все оставшиеся поля, фигурирующие в условии WHERE: title и from_date и сделаем ещё один анализ.
# Анализ запроса представлен на скриншоте lesson5Homework_3_3.png.
# Стоимость запроса в единицах MySQL составила     75256.
# Вывод: добавление одного индекса сильно ускоряет выполнение запроса, т.к. по нему сначала отсеивается большая часть ненужных данных.
# Последующее добавление индексов слабо влияет на скорость выполнения запроса, т.к. после выборки по первому индексу дальнейшие выборки
# выполняются уже на значительно меньшем количестве строк, и нет заметной разницы, перебирать эти строки все или частично.
# По большому счёту, для тяжёлого запроса имеет смысл создавать один индекс по полю, по которому отсеивается наибольшее число ненужных строк.